/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};

function __spreadArrays() {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
}

// https://github.com/lukeed/uid/blob/master/src/index.js
/* eslint no-bitwise: 'off' */
/* eslint no-plusplus: 'off' */
/* eslint @typescript-eslint/strict-boolean-expressions: 'off' */
var IDX = 36;
var HEX = '';
while (IDX--) {
    HEX += IDX.toString(36);
}
function uid(len) {
    if (len === void 0) { len = 11; }
    var str = '';
    var num = len;
    while (num--) {
        str += HEX[(Math.random() * 36) | 0];
    }
    return str;
}

// We need escape certain characters before creating the RegExp
// https://github.com/sindresorhus/escape-string-regexp
var escapeRegexp = function (term) {
    return term.replace(/[|\\{}()[\]^$+*?.-]/g, function (char) { return "\\" + char; });
};
var regexpQuery = function (_a) {
    var terms = _a.terms, _b = _a.matchExactly, matchExactly = _b === void 0 ? false : _b;
    if (typeof terms !== 'string') {
        throw new TypeError('Expected a string');
    }
    var escapedTerms = escapeRegexp(terms.trim());
    return "(" + (matchExactly ? escapedTerms : escapedTerms.split(' ').join('|')) + ")";
};

var hasProp = function (prop) { return function (obj) {
    return obj !== null && typeof obj !== 'undefined' && prop in obj;
}; };
var hasMatch = hasProp('match');
/**
 * This provides context around a chunk's text, based on the next and previous chunks.
 * e.g. If we have the string "The quick brown fox jumped over the lazy dog",
 * and the search term "fox jumped", with a padding of 2, we want to have the end result be:
 * "... quick brown fox jumped over the ..."
 * The search term, "fox jumped" is left as is, and the left and right chunks, instead of having
 * the text in full, will be clipped.
 */
function clip(_a) {
    var curr = _a.curr, next = _a.next, prev = _a.prev, _b = _a.clipBy, clipBy = _b === void 0 ? 3 : _b;
    var words = curr.text.split(' ');
    var len = words.length;
    // If the current is a match, we leave it alone
    // Or if the clipBy is greater than or equal to the length of the words, there's nothing to clip
    if (curr.match || clipBy >= len) {
        return curr.text;
    }
    // If we have a clipBy greater than the length of the words in the current match,
    // it means we can clip the words in the current chunk
    var ellipsis = '...';
    if (hasMatch(prev) && hasMatch(next)) {
        // Both the previous and the next chunks are a match
        // Let's check if we have enough words to clip by on both sides
        if (len > clipBy * 2) {
            return __spreadArrays(words.slice(0, clipBy), [
                ellipsis
            ], words.slice(-clipBy)).join(' ');
        }
        return curr.text;
    }
    // We start to check the next and previous matches in order to
    // properly position the elipsis
    if (hasMatch(next)) {
        // The chunk right after this one is a match
        // So we need the elipsis at the start of the returned text
        // so that it sticks correctly to the next (match)'s text
        return __spreadArrays([ellipsis], words.slice(-clipBy)).join(' ');
    }
    if (hasMatch(prev)) {
        // The chunk right before this one is a match
        // So we need the elipsis at the end of the                                 returned text
        // so that it sticks correctly to the previous (match)'s text
        return __spreadArrays(words.slice(0, clipBy), [ellipsis]).join(' ');
    }
    // If we made it this far, just return the text
    return curr.text;
}

var hasLength = function (str) { return str.length > 0; };
/**
 * Split a text into chunks denoting which are a match and which are not based on a user search term.
 * @param text          String  The text to split.
 * @param query         String  The query to split by. This can contain multiple words.
 * @param clipBy        Number  Clip the non-matches by a certain number of words to provide context around the matches.
 * @param matchExactly  Boolean If we have multiple words in the query, we will match any of the words if exact is false. For example, searching for "brown fox" in "the brown cute fox" will yield both "brown" and "fox" as matches. While if exact is true, the same search will return no results.
 */
var highlightWords = function (_a) {
    var text = _a.text, query = _a.query, clipBy = _a.clipBy, _b = _a.matchExactly, matchExactly = _b === void 0 ? false : _b;
    // Let's make sure that the user cannot pass in just a bunch of spaces
    var safeQuery = query.trim();
    if (safeQuery === '') {
        return [
            {
                key: uid(),
                text: text,
                match: false
            }
        ];
    }
    var searchRegexp = new RegExp(regexpQuery({ terms: safeQuery, matchExactly: matchExactly }), 'ig');
    return text
        .split(searchRegexp) // Split the entire thing into an array of matches and non-matches
        .filter(hasLength) // Filter any matches that have the text with length of 0
        .map(function (str) { return ({
        // Compose the object for a match
        key: uid(),
        text: str,
        match: matchExactly
            ? str.toLowerCase() === safeQuery.toLowerCase()
            : searchRegexp.test(str)
    }); })
        .map(function (chunk, index, chunks) { return (__assign(__assign({}, chunk), (typeof clipBy === 'number' && {
        // We only overwrite the text if there is a clip
        text: clip(__assign(__assign(__assign({ curr: chunk }, (index < chunks.length - 1 && { next: chunks[index + 1] })), (index > 0 && { prev: chunks[index - 1] })), { // If this wasn't the first chunk, set the previous chunk
            clipBy: clipBy }))
    }))); });
};

export default highlightWords;

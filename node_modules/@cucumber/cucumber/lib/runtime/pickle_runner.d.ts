/// <reference types="node" />
import { IdGenerator, messages } from '@cucumber/messages';
import { EventEmitter } from 'events';
import { ISupportCodeLibrary, ITestCaseHookParameter } from '../support_code_library_builder/types';
import TestCaseHookDefinition from '../models/test_case_hook_definition';
import TestStepHookDefinition from '../models/test_step_hook_definition';
import StepDefinition from '../models/step_definition';
import { IDefinition } from '../models/definition';
import { ITestRunStopwatch } from './stopwatch';
interface ITestStep {
    id: string;
    isBeforeHook?: boolean;
    isHook: boolean;
    hookDefinition?: TestCaseHookDefinition;
    stepHookDefinition?: TestStepHookDefinition;
    pickleStep?: messages.Pickle.IPickleStep;
    stepDefinitions?: StepDefinition[];
}
export interface INewPickleRunnerOptions {
    eventBroadcaster: EventEmitter;
    stopwatch: ITestRunStopwatch;
    gherkinDocument: messages.IGherkinDocument;
    newId: IdGenerator.NewId;
    pickle: messages.IPickle;
    retries: number;
    skip: boolean;
    supportCodeLibrary: ISupportCodeLibrary;
    worldParameters: any;
}
export default class PickleRunner {
    private readonly attachmentManager;
    private currentTestCaseStartedId;
    private currentTestStepId;
    private readonly eventBroadcaster;
    private readonly stopwatch;
    private readonly gherkinDocument;
    private readonly newId;
    private readonly pickle;
    private readonly maxAttempts;
    private readonly skip;
    private readonly supportCodeLibrary;
    private readonly testCaseId;
    private readonly testSteps;
    private testStepResults;
    private world;
    private readonly worldParameters;
    constructor({ eventBroadcaster, stopwatch, gherkinDocument, newId, pickle, retries, skip, supportCodeLibrary, worldParameters, }: INewPickleRunnerOptions);
    resetTestProgressData(): void;
    buildTestSteps(): ITestStep[];
    emitTestCase(): void;
    private mapArgumentGroup;
    getAfterHookDefinitions(): TestCaseHookDefinition[];
    getBeforeHookDefinitions(): TestCaseHookDefinition[];
    getBeforeStepHookDefinitions(): TestStepHookDefinition[];
    getAfterStepHookDefinitions(): TestStepHookDefinition[];
    getStepDefinitions(pickleStep: messages.Pickle.IPickleStep): StepDefinition[];
    getWorstStepResult(): messages.TestStepFinished.ITestStepResult;
    invokeStep(step: messages.Pickle.IPickleStep, stepDefinition: IDefinition, hookParameter?: any): Promise<messages.TestStepFinished.ITestStepResult>;
    isSkippingSteps(): boolean;
    shouldSkipHook(isBeforeHook: boolean): boolean;
    aroundTestStep(testStepId: string, attempt: number, runStepFn: () => Promise<messages.TestStepFinished.ITestStepResult>): Promise<void>;
    run(): Promise<messages.TestStepFinished.TestStepResult.Status>;
    runHook(hookDefinition: TestCaseHookDefinition, hookParameter: ITestCaseHookParameter, isBeforeHook: boolean): Promise<messages.TestStepFinished.ITestStepResult>;
    runStepHooks(stepHooks: TestStepHookDefinition[], stepResult?: messages.TestStepFinished.ITestStepResult): Promise<messages.TestStepFinished.ITestStepResult[]>;
    runStep(testStep: ITestStep): Promise<messages.TestStepFinished.ITestStepResult>;
}
export {};

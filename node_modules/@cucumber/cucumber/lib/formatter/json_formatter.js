"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const lodash_1 = __importDefault(require("lodash"));
const _1 = __importDefault(require("./"));
const status_1 = __importDefault(require("../status"));
const helpers_1 = require("./helpers");
const time_1 = require("../time");
const path_1 = __importDefault(require("path"));
const gherkin_document_parser_1 = require("./helpers/gherkin_document_parser");
const value_checker_1 = require("../value_checker");
const step_arguments_1 = require("../step_arguments");
const { getGherkinStepMap, getGherkinScenarioMap } = helpers_1.GherkinDocumentParser;
const { getScenarioDescription, getPickleStepMap, getStepKeyword, } = helpers_1.PickleParser;
class JsonFormatter extends _1.default {
    constructor(options) {
        super(options);
        console.warn("The built-in JSON formatter is deprecated and will be removed in the next major release. Where you need a structured data representation of your test run, it's best to use the `message` formatter. For legacy tools that depend on the deprecated JSON format, a standalone formatter is available (see https://github.com/cucumber/cucumber/tree/master/json-formatter).");
        options.eventBroadcaster.on('envelope', (envelope) => {
            if (value_checker_1.doesHaveValue(envelope.testRunFinished)) {
                this.onTestRunFinished();
            }
        });
    }
    convertNameToId(obj) {
        return obj.name.replace(/ /g, '-').toLowerCase();
    }
    formatDataTable(dataTable) {
        return {
            rows: dataTable.rows.map((row) => ({ cells: lodash_1.default.map(row.cells, 'value') })),
        };
    }
    formatDocString(docString, gherkinStep) {
        return {
            content: docString.content,
            line: gherkinStep.docString.location.line,
        };
    }
    formatStepArgument(stepArgument, gherkinStep) {
        if (value_checker_1.doesNotHaveValue(stepArgument)) {
            return [];
        }
        return [
            step_arguments_1.parseStepArgument(stepArgument, {
                dataTable: (dataTable) => this.formatDataTable(dataTable),
                docString: (docString) => this.formatDocString(docString, gherkinStep),
            }),
        ];
    }
    onTestRunFinished() {
        const groupedTestCaseAttempts = {};
        lodash_1.default.each(this.eventDataCollector.getTestCaseAttempts(), (testCaseAttempt) => {
            if (!testCaseAttempt.worstTestStepResult.willBeRetried) {
                const uri = path_1.default.relative(this.cwd, testCaseAttempt.pickle.uri);
                if (value_checker_1.doesNotHaveValue(groupedTestCaseAttempts[uri])) {
                    groupedTestCaseAttempts[uri] = [];
                }
                groupedTestCaseAttempts[uri].push(testCaseAttempt);
            }
        });
        const features = lodash_1.default.map(groupedTestCaseAttempts, (group, uri) => {
            const { gherkinDocument } = group[0];
            const gherkinStepMap = getGherkinStepMap(gherkinDocument);
            const gherkinScenarioMap = getGherkinScenarioMap(gherkinDocument);
            const gherkinExampleRuleMap = gherkin_document_parser_1.getGherkinExampleRuleMap(gherkinDocument);
            const gherkinScenarioLocationMap = gherkin_document_parser_1.getGherkinScenarioLocationMap(gherkinDocument);
            const elements = group.map((testCaseAttempt) => {
                const { pickle } = testCaseAttempt;
                const pickleStepMap = getPickleStepMap(pickle);
                let isBeforeHook = true;
                const steps = testCaseAttempt.testCase.testSteps.map((testStep) => {
                    isBeforeHook = isBeforeHook && testStep.pickleStepId === '';
                    return this.getStepData({
                        isBeforeHook,
                        gherkinStepMap,
                        pickleStepMap,
                        testStep,
                        testStepAttachments: testCaseAttempt.stepAttachments[testStep.id],
                        testStepResult: testCaseAttempt.stepResults[testStep.id],
                    });
                });
                return this.getScenarioData({
                    feature: gherkinDocument.feature,
                    gherkinScenarioLocationMap,
                    gherkinExampleRuleMap,
                    gherkinScenarioMap,
                    pickle,
                    steps,
                });
            });
            return this.getFeatureData({
                feature: gherkinDocument.feature,
                elements,
                uri,
            });
        });
        this.log(JSON.stringify(features, null, 2));
    }
    getFeatureData({ feature, elements, uri, }) {
        return {
            description: feature.description,
            elements,
            id: this.convertNameToId(feature),
            line: feature.location.line,
            keyword: feature.keyword,
            name: feature.name,
            tags: this.getFeatureTags(feature),
            uri,
        };
    }
    getScenarioData({ feature, gherkinScenarioLocationMap, gherkinExampleRuleMap, gherkinScenarioMap, pickle, steps, }) {
        const description = getScenarioDescription({
            pickle,
            gherkinScenarioMap,
        });
        return {
            description,
            id: this.formatScenarioId({ feature, pickle, gherkinExampleRuleMap }),
            keyword: gherkinScenarioMap[pickle.astNodeIds[0]].keyword,
            line: gherkinScenarioLocationMap[pickle.astNodeIds[0]].line,
            name: pickle.name,
            steps,
            tags: this.getScenarioTags({ feature, pickle, gherkinScenarioMap }),
            type: 'scenario',
        };
    }
    formatScenarioId({ feature, pickle, gherkinExampleRuleMap, }) {
        let parts;
        const rule = gherkinExampleRuleMap[pickle.astNodeIds[0]];
        if (value_checker_1.doesHaveValue(rule)) {
            parts = [feature, rule, pickle];
        }
        else {
            parts = [feature, pickle];
        }
        return parts.map((part) => this.convertNameToId(part)).join(';');
    }
    getStepData({ isBeforeHook, gherkinStepMap, pickleStepMap, testStep, testStepAttachments, testStepResult, }) {
        const data = {};
        if (testStep.pickleStepId !== '') {
            const pickleStep = pickleStepMap[testStep.pickleStepId];
            data.arguments = this.formatStepArgument(pickleStep.argument, gherkinStepMap[pickleStep.astNodeIds[0]]);
            data.keyword = getStepKeyword({ pickleStep, gherkinStepMap });
            data.line = gherkinStepMap[pickleStep.astNodeIds[0]].location.line;
            data.name = pickleStep.text;
        }
        else {
            data.keyword = isBeforeHook ? 'Before' : 'After';
            data.hidden = true;
        }
        if (testStep.stepDefinitionIds.length === 1) {
            const stepDefinition = this.supportCodeLibrary.stepDefinitions.find((s) => s.id === testStep.stepDefinitionIds[0]);
            data.match = { location: helpers_1.formatLocation(stepDefinition) };
        }
        const { message, status } = testStepResult;
        data.result = { status: status_1.default[status].toLowerCase() };
        if (value_checker_1.doesHaveValue(testStepResult.duration)) {
            data.result.duration = time_1.durationToNanoseconds(testStepResult.duration);
        }
        if (status === status_1.default.FAILED && value_checker_1.doesHaveValue(message)) {
            data.result.error_message = message;
        }
        if (lodash_1.default.size(testStepAttachments) > 0) {
            data.embeddings = testStepAttachments.map((attachment) => ({
                data: attachment.body,
                mime_type: attachment.mediaType,
            }));
        }
        return data;
    }
    getFeatureTags(feature) {
        return lodash_1.default.map(feature.tags, (tagData) => ({
            name: tagData.name,
            line: tagData.location.line,
        }));
    }
    getScenarioTags({ feature, pickle, gherkinScenarioMap, }) {
        return lodash_1.default.map(pickle.tags, (tagData) => {
            const featureSource = feature.tags.find((t) => t.id === tagData.astNodeId);
            const scenarioSource = gherkinScenarioMap[pickle.astNodeIds[0]].tags.find((t) => t.id === tagData.astNodeId);
            const line = value_checker_1.doesHaveValue(featureSource)
                ? featureSource.location.line
                : scenarioSource.location.line;
            return {
                name: tagData.name,
                line,
            };
        });
    }
}
exports.default = JsonFormatter;
//# sourceMappingURL=json_formatter.js.map
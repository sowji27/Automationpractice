"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.adapterFactory = exports.CucumberAdapter = void 0;
const Cucumber = __importStar(require("cucumber"));
const mockery_1 = __importDefault(require("mockery"));
const is_glob_1 = __importDefault(require("is-glob"));
const glob_1 = __importDefault(require("glob"));
const path_1 = __importDefault(require("path"));
const reporter_1 = __importDefault(require("./reporter"));
const events_1 = require("events");
const utils_1 = require("@wdio/utils");
const constants_1 = require("./constants");
const utils_2 = require("./utils");
class CucumberAdapter {
    constructor(cid, config, specs, capabilities, reporter) {
        this.cwd = process.cwd();
        this.cid = cid;
        this.specs = specs;
        this.reporter = reporter;
        this.capabilities = capabilities;
        this.config = config;
        this.cucumberOpts = Object.assign(constants_1.DEFAULT_OPTS, config.cucumberOpts);
        this._hasTests = true;
        this.cucumberFeaturesWithLineNumbers = this.config.cucumberFeaturesWithLineNumbers || [];
        this.eventBroadcaster = new events_1.EventEmitter();
    }
    async init() {
        try {
            const reporterOptions = {
                capabilities: this.capabilities,
                ignoreUndefinedDefinitions: Boolean(this.cucumberOpts.ignoreUndefinedDefinitions),
                failAmbiguousDefinitions: Boolean(this.cucumberOpts.failAmbiguousDefinitions),
                tagsInTitle: Boolean(this.cucumberOpts.tagsInTitle),
                scenarioLevelReporter: Boolean(this.cucumberOpts.scenarioLevelReporter)
            };
            this.cucumberReporter = new reporter_1.default(this.eventBroadcaster, reporterOptions, this.cid, this.specs, this.reporter);
            const featurePathsToRun = this.cucumberFeaturesWithLineNumbers.length > 0 ? this.cucumberFeaturesWithLineNumbers : this.specs;
            const pickleFilter = new Cucumber.PickleFilter({
                featurePaths: featurePathsToRun,
                names: this.cucumberOpts.name,
                tagExpression: this.cucumberOpts.tagExpression
            });
            const eventBroadcasterProxyFilter = new events_1.EventEmitter();
            this.eventBroadcaster.eventNames()
                .forEach(n => eventBroadcasterProxyFilter.addListener(n, (...args) => (n !== 'pickle-accepted' || this.filter(args[0])) && this.eventBroadcaster.emit(n, ...args)));
            this.testCases = (await Cucumber.getTestCasesFromFilesystem({
                cwd: this.cwd,
                eventBroadcaster: eventBroadcasterProxyFilter,
                featurePaths: this.specs,
                order: this.cucumberOpts.order,
                pickleFilter
            })).filter(testCase => this.filter(testCase));
            this._hasTests = this.testCases.length > 0;
        }
        catch (runtimeError) {
            await utils_1.executeHooksWithArgs('after', this.config.after, [runtimeError, this.capabilities, this.specs]);
            throw runtimeError;
        }
        const { setOptions } = require('expect-webdriverio');
        setOptions({
            wait: this.config.waitforTimeout,
            interval: this.config.waitforInterval,
        });
        return this;
    }
    hasTests() {
        return this._hasTests;
    }
    async run() {
        let runtimeError;
        let result;
        try {
            this.registerRequiredModules();
            Cucumber.supportCodeLibraryBuilder.reset(this.cwd);
            this.addWdioHooks(this.config);
            this.loadSpecFiles();
            this.wrapSteps(this.config);
            utils_2.setUserHookNames(Cucumber.supportCodeLibraryBuilder.options);
            Cucumber.setDefaultTimeout(this.cucumberOpts.timeout);
            const supportCodeLibrary = Cucumber.supportCodeLibraryBuilder.finalize();
            this.getCurrentStep = this.cucumberReporter
                .eventListener
                .getCurrentStep
                .bind(this.cucumberReporter.eventListener);
            const runtime = new Cucumber.Runtime({
                eventBroadcaster: this.eventBroadcaster,
                options: this.cucumberOpts,
                supportCodeLibrary,
                testCases: this.testCases
            });
            result = await runtime.start() ? 0 : 1;
            if (this.cucumberOpts.ignoreUndefinedDefinitions && result) {
                result = this.cucumberReporter.failedCount;
            }
        }
        catch (e) {
            runtimeError = e;
            result = 1;
        }
        await utils_1.executeHooksWithArgs('after', this.config.after, [runtimeError || result, this.capabilities, this.specs]);
        if (runtimeError) {
            throw runtimeError;
        }
        return result;
    }
    filter(testCase) {
        const skipTag = /^@skip\((.*)\)$/;
        const match = (value, expr) => {
            if (Array.isArray(expr)) {
                return expr.indexOf(value) >= 0;
            }
            else if (expr instanceof RegExp) {
                return expr.test(value);
            }
            return (expr && ('' + expr).toLowerCase()) === (value && ('' + value).toLowerCase());
        };
        const parse = (skipExpr) => skipExpr.split(';').reduce((acc, splitItem) => {
            const pos = splitItem.indexOf('=');
            if (pos > 0) {
                acc[splitItem.substring(0, pos)] = eval(splitItem.substring(pos + 1));
            }
            return acc;
        }, {});
        return !(testCase.pickle && testCase.pickle.tags && testCase.pickle.tags
            .map(p => p.name.match(skipTag))
            .filter(m => m).map(m => parse(m[1]))
            .find(filter => Object.keys(filter)
            .every(key => match(this.capabilities[key], filter[key]))));
    }
    registerRequiredModules() {
        this.cucumberOpts.requireModule.map(requiredModule => {
            if (Array.isArray(requiredModule)) {
                require(requiredModule[0])(requiredModule[1]);
            }
            else if (typeof requiredModule === 'function') {
                requiredModule();
            }
            else {
                require(requiredModule);
            }
        });
    }
    requiredFiles() {
        return this.cucumberOpts.require.reduce((files, requiredFile) => files.concat(is_glob_1.default(requiredFile)
            ? glob_1.default.sync(requiredFile)
            : [requiredFile]), []);
    }
    loadSpecFiles() {
        mockery_1.default.enable({
            useCleanCache: false,
            warnOnReplace: false,
            warnOnUnregistered: false
        });
        mockery_1.default.registerMock('cucumber', Cucumber);
        this.requiredFiles().forEach((codePath) => {
            const filepath = path_1.default.isAbsolute(codePath)
                ? codePath
                : path_1.default.join(process.cwd(), codePath);
            delete require.cache[require.resolve(filepath)];
            require(filepath);
        });
        mockery_1.default.disable();
    }
    addWdioHooks(config) {
        Cucumber.Before(function wdioHookBeforeScenario(world) {
            const { uri, feature } = utils_2.getDataFromResult(global.result);
            return utils_1.executeHooksWithArgs('beforeScenario', config.beforeScenario, [uri, feature, world.pickle, world.sourceLocation, world]);
        });
        Cucumber.After(function wdioHookAfterScenario(world) {
            const { uri, feature } = utils_2.getDataFromResult(global.result);
            return utils_1.executeHooksWithArgs('afterScenario', config.afterScenario, [uri, feature, world.pickle, world.result, world.sourceLocation, world]);
        });
        Cucumber.BeforeAll(function wdioHookBeforeFeature() {
            const { uri, feature, scenarios } = utils_2.getDataFromResult(global.result);
            return utils_1.executeHooksWithArgs('beforeFeature', config.beforeFeature, [uri, feature, scenarios]);
        });
        Cucumber.AfterAll(function wdioHookAfterFeature() {
            const { uri, feature, scenarios } = utils_2.getDataFromResult(global.result);
            return utils_1.executeHooksWithArgs('afterFeature', config.afterFeature, [uri, feature, scenarios]);
        });
    }
    wrapSteps(config) {
        const wrapStep = this.wrapStep;
        const cid = this.cid;
        const getCurrentStep = () => this.getCurrentStep();
        Cucumber.setDefinitionFunctionWrapper((fn, options = {}) => {
            if (fn.name.startsWith('wdioHook')) {
                return fn;
            }
            const isStep = !fn.name.startsWith('userHook');
            const retryTest = isStep && isFinite(options.retry) ? parseInt(options.retry, 10) : 0;
            return wrapStep(fn, retryTest, isStep, config, cid, getCurrentStep);
        });
    }
    wrapStep(code, retryTest = 0, isStep, config, cid, getCurrentStep) {
        return function (...args) {
            const { uri, feature } = utils_2.getDataFromResult(global.result);
            const beforeFn = isStep ? config.beforeStep : config.beforeHook;
            const afterFn = isStep ? config.afterStep : config.afterHook;
            const hookParams = { uri, feature, step: getCurrentStep() };
            return utils_1.testFnWrapper.call(this, isStep ? 'Step' : 'Hook', { specFn: code, specFnArgs: args }, { beforeFn, beforeFnArgs: (context) => [hookParams, context] }, { afterFn, afterFnArgs: (context) => [hookParams, context] }, cid, retryTest);
        };
    }
}
exports.CucumberAdapter = CucumberAdapter;
const _CucumberAdapter = CucumberAdapter;
const adapterFactory = {};
exports.adapterFactory = adapterFactory;
adapterFactory.init = async function (...args) {
    const adapter = new _CucumberAdapter(...args);
    const instance = await adapter.init();
    return instance;
};
exports.default = adapterFactory;

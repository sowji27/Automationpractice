"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getAllSteps = exports.enhanceStepWithPickleData = exports.getTestCaseSteps = exports.setUserHookNames = exports.getDataFromResult = exports.compareScenarioLineWithSourceLine = exports.buildStepPayload = exports.getStepType = exports.formatMessage = exports.getUniqueIdentifier = exports.getTestFullTitle = exports.getTestStepTitle = exports.getTestParent = exports.createStepArgument = void 0;
const path = __importStar(require("path"));
const utils_1 = require("@wdio/utils");
const constants_1 = require("./constants");
function createStepArgument({ argument }) {
    if (!argument) {
        return undefined;
    }
    if (argument.type === 'DataTable') {
        return {
            rows: argument.rows.map(row => ({
                cells: row.cells.map(cell => cell.value),
                locations: row.cells.map(cell => cell.location)
            }))
        };
    }
    if (argument.type === 'DocString') {
        return argument.content;
    }
    return undefined;
}
exports.createStepArgument = createStepArgument;
function getTestParent(feature, scenario) {
    return `${feature.name || 'Undefined Feature'}: ${scenario.name || 'Undefined Scenario'}`;
}
exports.getTestParent = getTestParent;
function getTestStepTitle(keyword = '', text = '', type) {
    const title = (!text && type !== 'hook') ? 'Undefined Step' : text;
    return `${keyword.trim()} ${title.trim()}`.trim();
}
exports.getTestStepTitle = getTestStepTitle;
function getTestFullTitle(parent, stepTitle) {
    return `${parent}: ${stepTitle}`;
}
exports.getTestFullTitle = getTestFullTitle;
function getUniqueIdentifier(target, sourceLocation) {
    if (target.type === 'Hook') {
        return `${path.basename(target.location.uri)}${target.location.line}`;
    }
    if (target.type === 'ScenarioOutline') {
        let name = target.name || target.text;
        const line = sourceLocation.line || '';
        if (!name) {
            console.warn('missing name for ScenarioOutline:', sourceLocation.uri);
            name = path.basename(sourceLocation.uri);
        }
        else if (Array.isArray(target.examples)) {
            target.examples.forEach((example) => {
                example.tableHeader.cells.forEach((header, idx) => {
                    if (name.indexOf('<' + header.value + '>') === -1) {
                        return;
                    }
                    example.tableBody.forEach((tableEntry) => {
                        if (tableEntry.location.line === sourceLocation.line) {
                            name = name.replace('<' + header.value + '>', tableEntry.cells[idx].value);
                        }
                    });
                });
            });
        }
        return `${name}${line}`;
    }
    const name = target.name || target.text;
    const location = target.location || target.locations[0];
    const line = (location && location.line) || '';
    return `${name}${line}`;
}
exports.getUniqueIdentifier = getUniqueIdentifier;
function formatMessage({ payload = {} }) {
    let content = { ...payload };
    if (payload.error && (payload.error.message || payload.error.stack)) {
        const { name, message, stack } = payload.error;
        content.error = { name, message, stack };
    }
    if (payload.title && payload.parent) {
        content.fullTitle = getTestFullTitle(payload.parent, payload.title);
    }
    return content;
}
exports.formatMessage = formatMessage;
function getStepType(type) {
    return type === 'Step' ? 'test' : 'hook';
}
exports.getStepType = getStepType;
function buildStepPayload(uri, feature, scenario, step, params = {}) {
    return {
        uid: getUniqueIdentifier(step),
        title: getTestStepTitle(step.keyword, step.text, params.type),
        parent: getTestParent(feature, scenario),
        argument: createStepArgument(step),
        file: uri,
        tags: scenario.tags,
        keyword: step.keyword,
        featureName: feature.name,
        scenarioName: scenario.name,
        ...params
    };
}
exports.buildStepPayload = buildStepPayload;
function compareScenarioLineWithSourceLine(scenario, sourceLocation) {
    if (scenario.type.indexOf('ScenarioOutline') > -1) {
        return scenario.examples
            .some(example => example.tableBody
            .some(tableEntry => tableEntry.location.line === sourceLocation.line));
    }
    return scenario.location.line === sourceLocation.line;
}
exports.compareScenarioLineWithSourceLine = compareScenarioLineWithSourceLine;
exports.getDataFromResult = ([{ uri }, feature, ...scenarios]) => ({ uri, feature, scenarios });
function setUserHookNames(options) {
    constants_1.CUCUMBER_HOOK_DEFINITION_TYPES.forEach(hookName => {
        options[hookName].forEach(testRunHookDefinition => {
            const hookFn = testRunHookDefinition.code;
            if (!hookFn.name.startsWith('wdioHook')) {
                const userHookAsyncFn = async function (...args) { return hookFn.apply(this, args); };
                const userHookFn = function (...args) { return hookFn.apply(this, args); };
                testRunHookDefinition.code = (utils_1.isFunctionAsync(hookFn)) ? userHookAsyncFn : userHookFn;
            }
        });
    });
}
exports.setUserHookNames = setUserHookNames;
function getTestCaseSteps(feature, scenario, pickle, testCasePreparedEvent) {
    const allSteps = getAllSteps(feature, scenario);
    const steps = testCasePreparedEvent.steps.map(eventStep => {
        let step = allSteps.find(scenarioStep => {
            const location = scenarioStep.location || {};
            if (eventStep.sourceLocation && eventStep.sourceLocation.uri === testCasePreparedEvent.sourceLocation.uri) {
                return typeof location.uri === 'undefined' && eventStep.sourceLocation.line === location.line;
            }
            return eventStep.actionLocation.uri === location.uri && eventStep.actionLocation.line === location.line;
        });
        if (step && eventStep.sourceLocation) {
            step = enhanceStepWithPickleData(step, pickle);
        }
        return step ? step : {
            type: 'Hook',
            location: { ...eventStep.actionLocation },
            keyword: 'Hook',
            text: ''
        };
    });
    return steps;
}
exports.getTestCaseSteps = getTestCaseSteps;
function enhanceStepWithPickleData(origStep, pickle) {
    const step = { ...origStep };
    const pickleStep = pickle.steps.find(s => s.locations.some(loc => loc.line === step.location.line));
    if (pickleStep) {
        step.text = pickleStep.text;
        if (step.argument && step.argument.rows && Array.isArray(pickleStep.arguments)) {
            const pickleStepValueLocation = {};
            pickleStep.arguments.forEach(pStepArg => {
                pStepArg.rows.forEach(pStepRow => {
                    pStepRow.cells.forEach(pStepCell => {
                        if (!pickleStepValueLocation[pStepCell.location.line]) {
                            pickleStepValueLocation[pStepCell.location.line] = {};
                        }
                        pickleStepValueLocation[pStepCell.location.line][pStepCell.location.column] = pStepCell.value;
                    });
                });
            });
            step.argument.rows.forEach(stepRow => {
                stepRow.cells.forEach(stepCell => {
                    stepCell.value = pickleStepValueLocation[stepCell.location.line][stepCell.location.column];
                });
            });
        }
    }
    return step;
}
exports.enhanceStepWithPickleData = enhanceStepWithPickleData;
function getAllSteps(feature, scenario) {
    const allSteps = [];
    const background = feature.children.find((child) => child.type === 'Background');
    if (background) {
        allSteps.push(...background.steps);
    }
    allSteps.push(...scenario.steps);
    return allSteps;
}
exports.getAllSteps = getAllSteps;

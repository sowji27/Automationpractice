"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const events_1 = require("events");
const utils_1 = require("./utils");
class CucumberEventListener extends events_1.EventEmitter {
    constructor(eventBroadcaster) {
        super();
        this.gherkinDocEvents = [];
        this.acceptedPickles = [];
        this.currentPickle = null;
        this.currentStep = null;
        this.currentSteps = null;
        this.testCasePreparedEvents = [];
        eventBroadcaster
            .on('gherkin-document', this.onGherkinDocument.bind(this))
            .on('test-run-started', this.onTestRunStarted.bind(this))
            .on('pickle-accepted', this.onPickleAccepted.bind(this))
            .on('test-case-prepared', this.onTestCasePrepared.bind(this))
            .on('test-case-started', this.onTestCaseStarted.bind(this))
            .on('test-step-started', this.onTestStepStarted.bind(this))
            .on('test-step-finished', this.onTestStepFinished.bind(this))
            .on('test-case-finished', this.onTestCaseFinished.bind(this))
            .on('test-run-finished', this.onTestRunFinished.bind(this));
    }
    onGherkinDocument(gherkinDocEvent) {
        this.gherkinDocEvents.push(gherkinDocEvent);
    }
    onTestRunStarted() {
        const doc = this.gherkinDocEvents[this.gherkinDocEvents.length - 1];
        this.emit('before-feature', doc.uri, doc.document.feature);
    }
    onPickleAccepted(pickleEvent) {
        this.acceptedPickles.push(pickleEvent);
    }
    onTestCaseStarted(pickleEvent) {
        const { uri, pickle } = this.acceptedPickles.find(item => item.uri === pickleEvent.sourceLocation.uri &&
            item.pickle.locations[0].line === pickleEvent.sourceLocation.line);
        const doc = this.gherkinDocEvents.find(gde => gde.uri === uri).document;
        const feature = doc.feature;
        this.currentPickle = pickle;
        const testCasePreparedEvent = this.testCasePreparedEvents[this.testCasePreparedEvents.length - 1];
        const scenario = feature.children.find((child) => utils_1.compareScenarioLineWithSourceLine(child, testCasePreparedEvent.sourceLocation));
        this.currentSteps = utils_1.getTestCaseSteps(feature, scenario, pickle, testCasePreparedEvent);
        this.currentPickle.description = scenario.description;
        this.emit('before-scenario', uri, feature, this.currentPickle);
    }
    onTestStepStarted(testStepStartedEvent) {
        const sourceLocation = testStepStartedEvent.testCase.sourceLocation;
        const uri = sourceLocation.uri;
        const doc = this.gherkinDocEvents.find(gde => gde.uri === uri).document;
        const feature = doc.feature;
        const scenario = feature.children.find((child) => utils_1.compareScenarioLineWithSourceLine(child, sourceLocation));
        const step = this.currentSteps[testStepStartedEvent.index];
        if (step.type === 'Step') {
            this.currentStep = { uri, feature, scenario, step, sourceLocation };
        }
        this.emit('before-step', uri, feature, scenario, step, sourceLocation);
    }
    onTestCasePrepared(testCasePreparedEvent) {
        this.testCasePreparedEvents.push(testCasePreparedEvent);
        const sourceLocation = testCasePreparedEvent.sourceLocation;
        const uri = sourceLocation.uri;
        const doc = this.gherkinDocEvents.find(gde => gde.uri === uri).document;
        const scenario = doc.feature.children.find((child) => utils_1.compareScenarioLineWithSourceLine(child, sourceLocation));
        const hasScenarioHasHooks = scenario.steps.filter((step) => step.type === 'Hook').length > 0;
        if (hasScenarioHasHooks) {
            return;
        }
        const allSteps = testCasePreparedEvent.steps;
        allSteps.forEach((step, idx) => {
            if (step.sourceLocation) {
                return;
            }
            step.sourceLocation = { line: step.actionLocation.line, column: 0, uri: step.actionLocation.uri };
            const hook = {
                type: 'Hook',
                location: step.sourceLocation,
                keyword: 'Hook',
                text: ''
            };
            scenario.steps.splice(idx, 0, hook);
        });
    }
    onTestStepFinished(testStepFinishedEvent) {
        const sourceLocation = testStepFinishedEvent.testCase.sourceLocation;
        const uri = sourceLocation.uri;
        const doc = this.gherkinDocEvents.find(gde => gde.uri === uri).document;
        const feature = doc.feature;
        const scenario = feature.children.find((child) => utils_1.compareScenarioLineWithSourceLine(child, sourceLocation));
        const step = this.currentSteps[testStepFinishedEvent.index];
        const result = testStepFinishedEvent.result;
        this.emit('after-step', uri, feature, scenario, step, result, sourceLocation);
    }
    onTestCaseFinished(testCaseFinishedEvent) {
        const { sourceLocation, result } = testCaseFinishedEvent;
        const uri = sourceLocation.uri;
        const doc = this.gherkinDocEvents.find(gde => gde.uri === uri).document;
        const feature = doc.feature;
        const scenario = feature.children.find((child) => utils_1.compareScenarioLineWithSourceLine(child, sourceLocation));
        this.emit('after-scenario', uri, feature, scenario, result, sourceLocation);
        this.currentPickle = null;
        this.currentStep = null;
        this.currentSteps = null;
    }
    onTestRunFinished() {
        const gherkinDocEvent = this.gherkinDocEvents.pop();
        const uri = gherkinDocEvent.uri;
        const doc = gherkinDocEvent.document;
        const feature = doc.feature;
        this.emit('after-feature', uri, feature);
    }
    getCurrentStep() {
        return this.currentStep;
    }
}
exports.default = CucumberEventListener;
